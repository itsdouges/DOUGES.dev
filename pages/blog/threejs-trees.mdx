import heroImage from '/public/threejs-trees.png';
import { TreeComplete } from 'components/examples/threejs-trees/tree-complete';
import { PlaneBillboard } from 'components/examples/threejs-trees/plane-billboard';
import { PlaneAlpha } from 'components/examples/threejs-trees/plane-alpha';
import { TreeNoAlpha } from 'components/examples/threejs-trees/tree-no-alpha';

export const meta = {
  blurb:
    'Learn how to make beautiful fluffy trees for ThreeJS using the power of GLSL shaders and math.',
  heroImage,
  publishDate: '2022-11-10',
  tags: ['GAME DEV', 'GLSL', 'R3F', 'THREEJS', 'TUTORIAL'],
  title: 'Creating fluffy trees with ThreeJS',
};

I've been working on a [point & click game](https://twitter.com/itsdouges/status/1583776108943904769) using ThreeJS (...technically React Three Fiber) and I've gotten to the stage where I want to start filling out the environment.
I found this [awesome tutorial](https://www.youtube.com/watch?v=iASMFba7GeI) by Pontus Karlsson going into detail of how to make fluffy stylized trees and they look _fantastic_!

Unfortunately though this tutorial was made for Unity 3D,
not ThreeJS!
After a few days of [posting on Twitter](https://twitter.com/itsdouges/status/1587314407520235520) about it I've figured it out,
take a look:

<TreeComplete />

While my trees don't look as impressive I'm still pretty chuffed for how they turned out and it's been a great learning experience.

Keep reading for how the effect is made,
it's not as obvious as it seems!

# GLSL shaders

It's important to have some context on what GLSL shaders are.
They're small programs written in a C-like language that are ran on the GPU.
As it turns out ThreeJS is [made up of a ton of them](https://github.com/mrdoob/three.js/tree/da820c4dabc364c221571555c6f0b7034710b5d7/src/renderers/shaders)!
If you've ever used any ThreeJS material you've already indirectly used them,
how cool!

With WebGL there are two kinds of shaders:

1. Vertex shaders, which run over _each vertex_ of a mesh; and
2. Fragment shaders, which run over _every pixel_ of a mesh

Shaders have a bunch of built in types and operators,
for this article we'll primarily be playing with vectors which are classes that hold values such as xyz,
and uvw.

We'll also only focus on vertex shaders as we'll be transforming the verticies of the foliage to get the look we want.
The responsibility of a vertex shader is to at a minimum convert the vertex position from local space to clip space assigning the result to `gl_Position`.
There's a great article on [coordinate systems](https://learnopengl.com/Getting-started/Coordinate-Systems) if you want to learn more but the gist is:

1. Start at local space, vertex position relative to itself
1. Transform to world space, vertex position relative to the world
1. Transform to view space, vertex position relative to the camera
1. Transform to clip space, verticies are discarded when outside some range

{{IMAGEHERE}}

We won't be going much further into the fundamentals of GLSL shaders but if you're keen to really dig in I recommend SimonDev's paid course "[The Easiest Way to Learn GLSL](https://simondev.teachable.com/p/glsl-shaders-from-scratch?coupon_code=EARLYBIRD2022)".
I did it and really loved going through it!
He also has a [great Youtube channel](https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A).

# Prepping the mesh

Like many things that look amazing we need to use some tricks.
The first is prepping the mesh so each quad takes up the entire space of its UV map.

> UV mapping is the process of unwrapping a 3D model so it can be textured enabling something 3D to be represented as 2D.
>
> <br />
>
> {{IMAGE}}

Why do this?
Well in the vertex shader there is a global variable (a "uniform" in GLSL speak) that ThreeJS makes available called `uv`.
Remember the vertex shader runs over every vertex of a mesh which means the `uv` value of every vertex will always be `0` or `1` and we can use this data to modify the vertex position in interesting ways.

{{IMAGE}}

If you're using Blender like me you can do this in a few steps:

1. Go to UV editing mode
1. Select the faces of the foliage
1. Open the UV menu and click on reset

It'll end up looking like this:

{{IMAGE}}

# Getting the fluffy foliage look

For the foliage effect we want two things to happen to the quads:

1. Keep it facing the camera; and
1. Scale it up to cover a larger area

As it turns out having meshes always face the camera has a name —
"billboarding"!
If you've used `@react-three/drei` previously (I like calling it the lodash of React Three Fiber) you might be tempted to reach for the [Billboard component](https://github.com/pmndrs/drei#billboard) but it comes with a small caveat: it only affects the entire mesh,
not individual quads on a mesh!
It also doesn't solve the second problem of scaling the quads up.

> A mesh is made up of triangles of which there are three verticies to a triangle and two triangles make a "quad".
>
> <br />
>
> {{ IMAGEHERE }}

Instead we can use GLSL vertex shaders and our prepped mesh for the effect.
Here we've applied it to a plane,
try and rotate around and you'll see that it always stays (mostly) in view!

<PlaneBillboard />

Interestingly it's not actually a traditional billboard effect!
If it was the quad would always be in view when rotating around it with the camera,
instead stretches when not looking at it directly.

Let's go over what's happening.

## Translating relative to the camera

The entire effect is built on the fact that we can translate verticies relative to the camera.
Personally when I think of translating things in 3D space I think in local & world space so the mind blowing thing here is since GLSL shaders can move between coordinate spaces you can change the position when in each space!

To transform the local position into view space so it's relative to the camera we perform some math:

```glsl
vec4 worldViewPosition = modelViewMatrix * vec4(position, 1.0);
```

> ThreeJS provides global variables to shaders for convience. The `position` variable is the vertex position in local space which is then transformed through supplied matrixes like `modelViewMatrix`.

Now we can translate the vertex in view space.
If we add `1.0` to the `x` value:

```glsl
worldViewPosition.x += 1.0;
```

{{IMAGEHERE}}

We've now translated this vertex one unit to the right relative to the camera.
If we were to subtract `1.0` it would move one unit to the left.
This applies to all axis!

```glsl
worldViewPosition.z -= 1.0;
```

## Using UVs as an offset

Instead of hardcoding values for the translation we want to instead pass data to the shader somehow.
This is what we'll be using UVs for and why we needed to unwrap them in a specific way!
Using the value we get back from the global variable `uv` is all we need to do:

```glsl
vec2 offset = vec2(uv.x, uv.y);
```

{{IMAGEHERE}}

## Remapping UV offset

If you turn off the "remap UVs" checkbox in the example about you'll notice the translation is off center.
This is because `uv` values are between `[0.0, 1.0]`!
Instead we need them to be between `[-1.0, 1.0]`.

Remapping values is common in shaders and so a `remap` function exists to change an inputs known min and max values to new ones,
here we remap the `uv` min and max values from `[0.0, 1.0]` to `[-1.0, 1.0]`:

> While `remap` is common it isn't actually built into GLSL so you'll see it either copied & pasted or included via pragams.

```glsl
vec2 offset = vec2(
  remap(uv.x, 0.0, 1.0, -1.0, 1.0),
  remap(uv.y, 0.0, 1.0, -1.0, 1.0)
);
```

{{IMAGEHERE}}

## Performing the translation

Now we finish by adding the normalized offset to the `worldViewPosition`.

> Normalizing a vector involves changing all its values such as `x` and `y` so that its length equals one.
> Using the built in function we can take it for granted.

```glsl
vertexOffset = normalize(vertexOffset);

worldViewPosition += vec4(vertexOffset, 0.0);
```

From any angle each vertex is now translated across the cameras `xy` axis resulting in a billboard-like effect where from the front it looks proportionally the same but bigger and from all other angles as a stretched rectangle.

<TreeNoAlpha />

For foliage this works in our favour as it results in a subtler but still effective effect.

# Using alpha maps to make foliage

When writing shaders with ThreeJS there are two ways to do alpha maps,
the advanced way,
and the simple way.

The advanced way involves creating a fragment shader that calculates the color of each pixel of the mesh.
Doing this for just the alpha map isn't actually that much lines of code but then when you also want lighting to affect the mesh it's either more code you need to write in the shader (and it's a lot of math!) or alternatively you can include fragments from the ThreeJS shader library but that's still work.

> Understanding fragment shaders is still a great thing to have in your toolbox,
> definitely check out SimonDev's paid course "[The Easiest Way to Learn GLSL](https://simondev.teachable.com/p/glsl-shaders-from-scratch?coupon_code=EARLYBIRD2022)" if you're serious.

The simple way and what I ended up leaning on was [CustomShaderMaterial](https://github.com/FarazzShaikh/THREE-CustomShaderMaterial) —
it let's you keep using standard materials from ThreeJS so they're affected by scene lighting,
can take texture maps without needing to write a fragment shader,
and can be provided a custom vertex shader,
fragment shader,
or both!
In this case we've provided just the vertex shader.

<PlaneAlpha />

Perfect!
We had to make one change to the vertex shader however to apply the result to `csm_PositionRaw` instead of `gl_Position`.
This is because CustomShaderMaterial will pass it onto the ThreeJS material shader.

```diff
-gl_Position = projectionMatrix * worldViewPosition;
+csm_PositionRaw = projectionMatrix * worldViewPosition;
```

# Blowing wind onto the foliage
