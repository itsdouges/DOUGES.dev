import heroImage from '/public/threejs-trees.png';
import { Complete } from 'components/examples/threejs-trees/complete';
import { Billboard } from 'components/examples/threejs-trees/billboard';

export const meta = {
  blurb:
    'Learn how to make beautiful fluffy trees for ThreeJS using the power of GLSL shaders and math.',
  heroImage,
  publishDate: '2022-11-10',
  tags: ['GAME DEV', 'GLSL', 'R3F', 'THREEJS', 'TUTORIAL'],
  title: 'Creating fluffy trees with ThreeJS',
};

I've been working on a [point & click game](https://twitter.com/itsdouges/status/1583776108943904769?s=20&t=u20fJ2AtyC5wih8fVl20Yg) using ThreeJS (...technically React Three Fiber) and I've gotten to the stage where I want to start filling out the environment.
I found this [awesome tutorial](https://www.youtube.com/watch?v=iASMFba7GeI) by Pontus Karlsson going into detail of how to make fluffy stylized trees,
they look _fantastic_!

Unfortunately for me this tutorial was made for Unity 3D...
not ThreeJS!
After a few days of [posting on Twitter](https://twitter.com/itsdouges/status/1587314407520235520) about it I've mostly figured it out,
check it out!

<Complete />

While my trees don't look as impressive I'm still pretty chuffed for how they turned out.
Keep reading for how I did it!
Things are going to get technical fast so if you have knowledge of:

- 3D modelling
- ThreeJS
- GLSL shaders; and
- Math

Then everything will make more sense but if not don't fret!
I'll explain as we go on.

# GLSL vertex shaders

It's important to have some context on what GLSL shaders are.
They're small programs written in a C-like language that are ran on the GPU.
As it turns out ThreeJS is [made up of a ton of them](https://github.com/mrdoob/three.js/tree/da820c4dabc364c221571555c6f0b7034710b5d7/src/renderers/shaders)!
If you've ever used any ThreeJS material before you've already indirectly used them,
how cool!

With WebGL there are two kinds of shaders:

1. Vertex shaders, which run over _each vertex_ of a mesh; and
2. Fragment shaders, which run over _every pixel_ of a mesh

Shaders have a bunch of built in types and operators,
for this article we'll primarily be playing with vectors which are classes that hold values such as xyz,
and uvw.

For this article we're only going to be looking at vertex shaders as we'll be transforming the verticies of the foliage to get the look we want.
The responsibility of a vertex shader is to at a minimum convert the vertex position from local space to clip space assigning the result to `gl_Position`.
There's a great article on [coordinate systems](https://learnopengl.com/Getting-started/Coordinate-Systems) if you want to learn more or look at ThreeJS' [program reference](https://threejs.org/docs/index.html?q=program#api/en/renderers/webgl/WebGLProgram) but the TL;DR is:

1. Start at local space, vertex position relative to itself
1. Transform to world space, vertex position relative to the world
1. Transform to view space, vertex position relative to the camera
1. Transform to clip space, verticies are discarded when outside some range

The cool bit though is during each conversion we're free to change the values as we see fit!

We won't be going much further into the fundamentals of GLSL shaders but if you're keen to really dig in I recommend SimonDev's paid course "[The Easiest Way to Learn GLSL](https://simondev.teachable.com/p/glsl-shaders-from-scratch?coupon_code=EARLYBIRD2022)".
I did it and really loved going through it!
He also has a [great Youtube channel](https://www.youtube.com/channel/UCEwhtpXrg5MmwlH04ANpL8A).

# Prepping the mesh

Like many things that look amazing we need to use some tricks.
The first is prepping the mesh so each quad takes up the entire space of its UV map.

> UV mapping is the process of unwrapping a 3D model so it can be textured enabling something 3D to be represented as 2D.
>
> <br />
>
> {{IMAGE}}

Why do this?
Well in the vertex shader there is a uniform (a global variable in GLSL speak) that ThreeJS makes available called `uv`.
Remember the vertex shader runs over every vertex of a mesh which means the `uv` value of every vertex will always be `0` or `1` and we can use this data to modify the vertex position in interesting ways.

{{IMAGE}}

If you're using Blender like me you can do this in a few steps:

1. Go to UV editing mode
1. Select the faces of the foliage
1. Open the UV menu and click on reset

It'll end up looking like this:

{{IMAGE}}

# Getting that fluffy foliage look

For the foliage effect we need to do two things to the quads:

1. Have them face the camera; and
1. Have them scaled up to cover more of the tree

As it turns out having meshes always face the camera has a name â€”
"billboarding"!
If you've used `@react-three/drei` previously (I like calling it the lodash of React Three Fiber) you might be tempted to reach for the [Billboard component](https://github.com/pmndrs/drei#billboard) but unfortunately it comes with a small caveat: it only affects the entire mesh,
not individual quads on a mesh!
It also doesn't solve the second problem of scaling the quads up.

> A mesh is made up of triangles of which there are three verticies to a triangle and two triangles make a "quad".
>
> <br />
>
> {{ IMAGEHERE }}

Instead thanks to GLSL vertex shaders and our prepped mesh we have everything we need for the effect.
Here we've applied the effect to a plane try and rotate around and you'll see that it always stays view.

<Billboard />

Let's go over what's happening.

## Offset from uv

First we want to get the initial offset from the uniform `uv` but we can't just use it as is.
This is because `uv` values will be between `0.0` and `1.0` and so the effect is only partially applied,
we need the values to instead be between `-1.0` and `1.0`.

This is common in shaders and so a `remap` function exists to change an inputs known min and max values to new min and max values,
here we remap the uv min and max values from `[0.0, 1.0]` to `[-1.0, 1.0]`:

```glsl
vec2 offset = vec2(
  remap(uv.x, 0.0, 1.0, -1.0, 1.0),
  remap(uv.y, 0.0, 1.0, -1.0, 1.0)
);
```

So for example the bottom left vertex on the UV map which would have had a value of `[0.0, 0.0]` it's now `[-1.0, -1.0]`.

## Moving into view space

Next we transform the position into view space so it's relative to the camera where we'll be applying the offset:

```glsl
vec4 worldViewPosition = modelViewMatrix * vec4(position, 1.0);
```

## Adding the offset

For each vertex of a quad we're only ever going to be applying one of four `[x, y]` values:

1. Bottom left vertex `[-1.0, -1.0]`
1. Bottom right vertex `[1.0, -1.0]`
1. Top left vertex `[1.0, -1.0]`
1. Top right vertex `[1.0, 1.0]`

Adding to a position vector in GLSL results in translating it across that axis,
so `vec.x` would translate it left and right, `vec.y` up and down, and so on.
By adding it to `worldViewPosition` (which is the "camera" view) the vertices are translated by this amount causing a stretch effect.

```glsl
worldViewPosition += vec4(vertexOffset, 0.0);
```

Play with the example above to see what happens when it's on and off.

# Using alpha maps to make foliage

# Blowing wind onto the foliage
