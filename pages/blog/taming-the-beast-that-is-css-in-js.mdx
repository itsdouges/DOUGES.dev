import AvatarExample from 'components/examples/avatar-ssr';

export const meta = {
  title: 'Taming the beast that is CSS-in-JS',
  blurb:
    'While working on the Atlassian Design System we found it difficult to analyze and evolve how we style our components. Read how we took control of our CSS-in-JS usage without needing to introduce another library.',
  publishDate: '2021-09-01',
};

CSS-in-JS is awesome.
When it was gaining traction I remember how freeing it was to use it â€“
in a time when [custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) weren't widely available they allowed us to create rich dynamic experiences right inside JavaScript!
Even better being able to consume a component library from [NPM](https://npmjs.com) without needing insane bundler configuration was made into a reality,
just import and go!
While working at [Atlassian](https://atlassian.com) I've had the privilage to work on the [Atlassian Design System](https://atlassian.design/) which leans heavily on CSS-in-JS to author styles.
During this time I've seen components styled with [styled-components](https://styled-components.com/) and [emotion](https://emotion.sh/docs/introduction),
styles defined using strings & objects,
and the costs you wouldn't immediately think about such as difficulty in statically analyzing style declarations,
performance gotchas,
and evolution stagnation.

There are benefits to be gained by adding constraints to how we use CSS-in-JS such as better performance,
static analysis,
and healthy code evolution without needing to jump to yet another library (for now).
Let's dig in.

## All the colors of the rainbow

One of the benefits of CSS-in-JS is that it is very flexible,
however that is also one of its biggest drawbacks.
The experiences we write today are very dynamic,
different appearances,
states,
and sizes,
with a few different ways to turn these on and off.
One common way I've seen combines styles using conditional object spreads but given a large enough prop set you're at risk of combinatorial explosion!

Let's have a play and see what that looks like in practice.

```jsx
const styles = (isDisabled) => {
  return {
    outline: 0,
    border: 0,
    backgroundColor: 'blue',
    ...isDisabled ? {
      opacity: 0.5,
      backgroundColor: 'gray',
    },
  };
};


function StyledComponent({ isDisabled }) {
  return <div css={styles(isDisabled)} />;
}
```

It get's increasingly more complex to understand this declaration both as a human and as a static analysis tool!

## Pulling back from infinity

As a codebase grows I find myself wanting to automate away all of the nitty gritty,
and work towards the holy grail of code consistency.
Amusingly however if you take the code above it turns out not having clear call sites for style declarations and complex style combination makes it difficult,
almost impossible to successfully lint and evolve the written styles.
In my opinion it also makes styles harder to reason about.

If we could come up with a list of "goals" to write the best CSS (in JS) what would they be?
My list includes:

- Clear call sites
- Typed declarations
- Easily scanned by engineers
- Encourages statically declared styles
- One way to style

To enact these we could set some constraints.
My list of constraints ends up being:

- Use CSS prop
- Use JS objects
- Styles must be declared in the top level scope
- Styles can't be imported or exported
- Styles can't be composed together in their own declarations

Applying these constraints to the example above it looks like this:

```jsx
const styles = css({
  outline: 0,
  border: 0,
  backgroundColor: 'blue',
});

const disabledStyles = css({
  opacity: 0.5,
  backgroundColor: 'gray',
});

function StyledComponent({ isDisabled }) {
  return <div css={[styles, isDisabled && disabledStyles]} />;
}
```

If you're feeling what I'm feeling you'll notice the output of this appears very similar to how you'd use CSS modules!
This isn't a coincidence.

## Tying it all together

Imposing constraints correlates to better outcomes in code even if it isn't immediately obvious.
Let's walk through a few examples of what is improved because of the constraints we've applied.

### Performance

Let's start with the more interesting aspect around performance.
These constraints generate less styles when rendered on the server,
have a play with this example.

<AvatarExample />

Notice there is an extra style block rendered to the HTML for every unique user,
versus when the constraints are applied only one is ever created.

### Code analysis

Linting falls under this bucket.
Style declarations written with these constraints are clear and simple,
so simple in fact that statically analysing them can be done exhaustively.
This is fantastic for the fact that you can write some very powerful rules for how these styles should be written.
Ordering,
disallowed styles,
enforced color usage,
even through to controlling how they are dynamically applied through CSS prop.

```
example linting here
```

### Code evolution

A logical next step when the code your write is easily staticly analyzable is that you can change it at scale.
Let's say we've decided that the library we're using isn't performance enough so we decide to move to a compile time solution.
We're now in a great position because it's very easy to automate the transformation!

Here's an example where we transform the code to use [vanilla-extract](https://vanilla-extract.style/),
have a play yourself!

```
each step of a transformation here
```

Because we know what the floor is,
the absolute worst case of how the code can be written,
we're in complete control.

## Not just limited to styling

Hopefully you've found this read as interesting as I did when I first starting reshaping how we style our experiences.
Finding constraints to apply to the code we write applies to more than just styling our experiences however!
Next time you're deep in your code base think through what opportunities might arise if you applied more constraints to how you write your state management,
your components,
and APIs.
You'll be suprised at what you find.
