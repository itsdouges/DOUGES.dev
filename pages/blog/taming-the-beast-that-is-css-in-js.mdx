export const meta = {
  title: 'Taming the beast that is CSS-in-JS',
  blurb:
    'While working on the Atlassian Design System we found it difficult to analyze and evolve how we style our components. Read how we took control of our CSS-in-JS usage without needing to introduce another library.',
  publishDate: '2021-09-01',
};

CSS-in-JS is awesome.
When it was gaining traction I remember how freeing it was to use it –
in a time when [custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/--*) weren't widely available they allowed us to create rich dynamic experiences right inside JavaScript!
Even better being able to consume a component library from [NPM](https://npmjs.com) without needing insane bundler configuration was made into a reality,
just import and go!
While working at [Atlassian](https://atlassian.com) I've had the privilage to work on the [Atlassian Design System](https://atlassian.design/) which leans heavily on CSS-in-JS to author styles.
During this time I've seen components styled with [styled-components](https://styled-components.com/) and [emotion](https://emotion.sh/docs/introduction),
styles defined using strings & objects and the costs you wouldn't immediately think about such as difficulty in statically analyzing style declarations,
performance gotchas,
and evolution stagnation.

There are benefits to be gained by adding constraints to how we use CSS-in-JS such as better performance,
static analysis,
and healthy code evolution without needing to jump to yet another library (for now).
Let's dig in.

## All the colors of the rainbow

One of the benefits of CSS-in-JS is that it is very flexible,
however that is also one of its biggest drawbacks.
The experiences we write today are very dynamic,
different appearances,
states,
and sizes,
with a few different ways to turn these on and off.
One common way I've seen combines styles using conditional object spreads but given a large enough prop set you're at risk of combinatorial explosion!

Let's have a play and see what that looks like in practice.

```jsx
const styles = (isDisabled) => {
  return {
    outline: 0,
    border: 0,
    backgroundColor: 'blue',
    ...isDisabled ? {
      opacity: 0.5,
      backgroundColor: 'gray',
    },
  };
};


function StyledComponent({ isDisabled }) {
  return <div css={styles(isDisabled)} />;
}
```

It get's increasingly more complex to understand this declaration both as a human and as a static analysis tool!

## Pulling back from infinity

As a codebase grows I find myself wanting to automate away all of the nitty gritty,
and work towards the holy grail of code consistency.
Amusingly however if you take the code above it turns out not having clear call sites for style declarations and complex style combination makes it difficult,
almost impossible to successfully lint and evolve the written styles.
In my opinion it also makes styles harder to reason about.

If we could come up with a list of "goals" to write the best CSS (in JS) what would they be?
My list includes:

- Clear call sites
- Typed declarations
- Easily scanned by engineers
- Encourages statically declared styles
- Styles have to be declared in the same module as the component
- Flowing through a single method of styling

To accomplish the goals we could set some constraints.
My list of constraints ends up being:

- Use CSS prop
- Use CSS objects
- Style declarations declared in the top level scope of a module
- Dynamic styles flow through inline styles

And after applying those constraingts if we transform the example above it looks like this:

```jsx
const styles = css({
  outline: 0,
  border: 0,
  backgroundColor: 'blue',
});

const disabledStyles = css({
  opacity: 0.5,
  backgroundColor: 'gray',
});

function StyledComponent({ isDisabled }) {
  return <div css={[styles, isDisabled && disabledStyles]} />;
}
```

If you're feeling what I'm feeling you'll notice the output of this appears very similar to how you'd use CSS modules!
This isn't a coincidence.

## What it means

The first line in the sand was making official something already implied,
use CSS prop.
With one hard requirement however to use values sourced from a `css` object.

```jsx
const styles = css({
  margin: 0,
});

<div css={styles} />;
```

Right off the bat we've already checked two items off the list.

- Clear call site ✅
- Typed declarations ✅

### Prefer static styles

- Declarations need to be top level
- Easily scanned by engineers ✅
- Exhaustively statically analysable ✅

### Dynamic inline styles

- Static through CSS, dynamic through styles
- User interaction cost (tons of styles generated) ⭐
- SSR amount of styles generated combination explode ⭐
- Example could be press a button to add an avatar during SSR

// example adding user data flowing through a single declaration vs. using inline styles

### Exhasutively linted

- Can't mix declarations together, combine in css prop
- Single module

## The future will come tomorrow

- Lint rules
- Moving to compile time library
- Codemod ⭐
