export const meta = {
  title: 'Defining systems and buying into them',
  blurb: 'What if we could make UI simple?',
  publishDate: '2021-10-07',
};

Believe it or not I play ice hockey for fun in Sydney,
Australia.
The higher the competitive ladder you climb the more common it is to have your coach define and apply systems to the way the team plays.
Whether you're attacking or defending there are systems in place ready to execute at any given moment.
In some ways this is a pretty fitting analogy for software development,
except we replace the competitive ladder with scale,
the coach with an engineering manager or architect,
and systems,
well,
systems still work.
When you're a prospect and being scouted the coach will always push for you to ["buy into their system"](https://www.ncsasports.org/blog/2014/07/28/buy-program/),
teams in software development aren't all that different,
truly.
We all want to be aligned so we can execute with precision and speed.

What systems could we define to make UI development easier?

# Boxes and borders

Today most web developers use `box-sizing: border-box` to enable [the alternative box model](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model#the_alternative_css_box_model) simplifying how we think about the size of an element rendered in the viewport.
Set an elements width to `100px` and it does exactly what you think it would.
But even with the alternative box model things can still be harder than we'd like them to be.
Borders for example are pretty easy to get started with,
but use them with multiple elements in different scenarios and they start behaving quite nefariously.
Let's dig in.

```
// example here showing a menu with left border for selected
```

You might be thinking,
"_Douges_,
mate,
this is easy!
You can work around this by ‚Ä¶" and honestly?
You're not wrong.
But let's look at another example first where we need multiple borders working with each other.

```
// tabs border example needing to overlay
```

More troubles.
More potential workarounds.
We need to think bigger past a single example and towards how it works with the entire system.
What if borders just worked well together so we could throw away our workarounds?

What if our system had borders applied using box shadow?

```
// side by side example of tabs and menu with box shadow
```

# Interactions and backgrounds

Interactive UI elements like borders are simple to get started.
Pick a few different background colors,
maybe even a little transform,
and you're done.
But what would it look like when we're at ùìåùëíùí∑ ùìàùí∏ùí∂ùìÅùëí?
Let's visualize it.

```
// interaction state explosion
```

I hope you agree with me that given enough use cases things are getting pretty wild,
and we haven't even touched on UI elements that don't work with backgrounds,
such as avatars!

Given the need for varying use cases and enough scale there are a load of decisions that are vectors for mistakes,
each one slowing us down.
If we were to add a new use case what would the appropriate interaction states be?
More decisions!
What if we could reduce the decisions we need to make for interaction states down to one?

What if our system had all interaction states applied as overlays?

```
// example of pressable
```

# APIs and unintentional bleeds

1. APIs bleeding through the system (for consumers, for maintainers)
1. Take a simple tooltip and apply it to your system
1. Zindex wars


# Layouts and text

1. Simplifying layout concerns with primitives and simply API (do things one way instead of multiple ways)
1. Abstraction CSS layout with powerful defaults to make it easy for everyone
1. Capsize to cut down text and make 2px padding mean 2px
1. Responsibility and concerns
1. Margins shouldn't be used anymore outside a set of specific scenarios
1. Gap is perfect for layout
1. Nested styles affect entropy of the system

# More than just systems

1. It's about bringing everyone on the journey
1. Make UI simple and focus on the hard problems
1. The best systems in the world mean nothing if everyone doesn't buy in
1. Need supporting tooling and abstractions
