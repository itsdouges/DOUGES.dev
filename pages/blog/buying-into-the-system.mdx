import BorderMenu from 'components/examples/defining-and-buying-into-systems/border-menu';
import BorderTabs from 'components/examples/defining-and-buying-into-systems/border-tabs';
import BorderShadow from 'components/examples/defining-and-buying-into-systems/border-shadow';
import InteractionsExplosion from 'components/examples/defining-and-buying-into-systems/interactions-explosion';
import InteractionsSingle from 'components/examples/defining-and-buying-into-systems/interactions-single';
import MarginChild from 'components/examples/defining-and-buying-into-systems/margin-child';
import MarginParent from 'components/examples/defining-and-buying-into-systems/margin-parent';
import MarginAbstraction from 'components/examples/defining-and-buying-into-systems/margin-abstraction';

export const meta = {
  title: 'Defining and buying into systems',
  blurb: 'What if we could make UI simple?',
  publishDate: '2021-10-21',
  tags: ['UI', 'DESIGN SYSTEMS', 'WEB DEV', 'CSS', 'SCALE'],
};

Believe it or not I [play ice hockey](https://twitter.com/itsdouges/status/1444889172410449925?s=20) [for fun](https://twitter.com/itsdouges/status/1371743285903912960) in Sydney,
Australia.
The higher the competitive ladder you climb [in sport] the more common it is to have your coach define and apply systems to the way the team plays.
Whether you're attacking or defending there are systems in place ready to execute at any given moment.
In some ways this is a pretty fitting analogy for software development,
except we replace the competitive ladder with scale,
the coach with an engineering manager or architect,
and systems,
well,
systems still work.
When you're a prospect and being scouted the coach will always push for you to "[buy into their system](https://www.ncsasports.org/blog/2014/07/28/buy-program/)" and teams in software development aren't all that different,
truly.
We all want to be aligned so we can execute with precision and speed.

What systems could we define to make UI development easier?

# Boxes and borders

Today most web developers use `box-sizing: border-box` to enable the [alternative box model](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model#the_alternative_css_box_model) simplifying how we think about the size of an element rendered in the viewport.
Set an elements width to `100px` and it does exactly what you think it would.
But even with the alternative box model things can still be harder than we'd like them to be.
Borders for example are pretty easy to get started with,
but use them with multiple elements in different scenarios and they start behaving quite nefariously.
Let's dig in.

<BorderMenu />

> Buying in to the [system] means that you love what you are a part of and your joy is infectious to everyone in the program.

You might be thinking,
"_Douges_,
mate,
this is easy!
That work around is [fine]â€¦" and honestly?
You're not wrong.
But let's look at another example first.

<BorderTabs />

More troubles.
More workarounds.
We need to think bigger,
past a single example and towards how it works with the entire system.

What if our system applied borders using box shadows?

<BorderShadow />

Well,
that's something!
Is it perfect in all scenarios?
Definitely not.
If you're a keen observer you'll notice when we "zoom" into the example using `transform` the box shadow bleeds around the element.
It's a tradeoff optimizing for cohesion over perfection throwing away the need to think through multiple moving parts and workarounds,
and one to be honest that I wouldn't pay until it's fixed.

# Interactions and backgrounds

Interactive UI elements like borders are simple to get started.
Pick a few different background colors,
maybe even a little transform,
and you're done.
But what would it look like when we're at _web scale_?
Let's visualize it.

<InteractionsExplosion />

Given enough use cases the need to define all interaction states get pretty wild,
and we haven't even touched on UI elements that don't work with backgrounds such as avatars!
Each needing decisions to move forward effectively from both design and engineering.

> Buying in to the [system] means that you are someone who knows how to stay in the moment.

Given the need for varying use cases and enough scale each decision is a vector for slowdowns and mistakes.
If we were to add a new use case what would the appropriate interaction states be?
More decisions!

What if our system had only one way to add interaction states to our elements?

<InteractionsSingle />

# Margin and layouts

Using margins is simple enough for a single experience,
used in a single area of your app.
But things get nefarious when that experience now needs to scale to fit other use cases,
in different areas of your app.

<MarginChild />

The logical next step is to move layout concerns to parent components instead.
These days thanks to flex box and grid it's very easy to accomplish...
but it's also very fiddly by default.

<MarginParent />

> Buying in to the [system] means that you are willing to hold yourself to the standard of what is expected of anyone who wears that uniform.

At _web scale_ we want to ensure developers are productive and have a pit of success,
that when they use something its _obvious_ how to do it properly,
with no foot guns.

What if our system had sensible layout abstractions with baked in design decisions?

<MarginAbstraction />

# Bringing it altogether

These are a few examples of things we can define in our system,
but they definitely aren't exhaustive.
Others could include accessibility attributes that should be available to all areas of your system and handling layering holistically to avoid z-index fights.

We should position ourselves with well defined boundaries and have room to grow,
BUT if that's all we did,
well,
our system would fall apart very easily.
We need sensible abstractions and tooling to scale it and keep everyone on the path.

> Buying in to the [system] means accepting your role,
> doing your job,
> and trusting the coaching staff and your teammates.

What abstractions would you build?
